# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Time::HiRes {
  
  version "0.001";
  
  use Fn;
  use Sys::Time;
  use Sys::Time::Timezone;
  use Sys::Signal;
  use Sys::Process;
  use Sys::Time::Timeval;
  use Sys::Time::Timespec;
  use Sys::Time::Itimerval;
  
  use Time::HiRes::ItimervalFloat;
  use Time::HiRes::FloatSecond;
  
  # Class Methods
  static method gettimeofday : Sys::Time::Timeval () {
  
    my $tv = Sys::Time::Timeval->new;
    
    Sys::Time->gettimeofday($tv, undef);
    
    return $tv;
  }
  
  static method usleep : int ($usec : long) {
    
    my $slept_time = Sys::Process->usleep($usec);
    
    return $slept_time;
  }
  
  static method nanosleep : int ($rqtp : Sys::Time::Timespec, $rmtp : Sys::Time::Timespec) {
    return Sys::Time->nanosleep($rqtp, $rmtp);
  }
  
  static method ualarm : int ($usecs : int, $interval : int = 0) {
    
    my $remain_time = Sys::Signal->ualarm($usecs, $interval);
    
    return $remain_time;
  }
  
  static method tv_interval : double ($a : Sys::Time::Timeval, $b : Sys::Time::Timeval = undef) {
    
    unless ($b) {
      $b = &gettimeofday;
    }
    
    my $tv_interval = ($b->tv_sec - $a->tv_sec) + ($b->tv_usec - $a->tv_usec) / 1_000_000;
    
    return $tv_interval;
  }
  
  # static method setitimer : int ($which : int, $new_value : Sys::Time::Itimerval, $old_value : Sys::Time::Itimerval);

=pod

  static method setitimer :  ( $which, $floating_seconds [, $interval_floating_seconds ] ) {
    
  }
  
  static method getitimer : Sys::Time::Itimerval ($which : int) {
    
    my $itimer = Sys::Time::Itimerval->new;
    
    Sys::Time->getitimer($which, $itimer);
    
    return $itimer;
  }
  
  # setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )
  
=cut

  static method clock_gettime : double ($clk_id : int) {
    
    my $ts = Sys::Time::Timespec->new;
    
    my $status = Sys::Time->clock_gettime($clk_id, $ts);
    
    my $ret = -1.0;
    if ($status == 0) {
      $ret = $ts->tv_sec + ($ts->tv_nsec / 1_000_000_000.0);
    }
    
    return $ret;
  }
  
  static method clock_getres : double ($clk_id : int) {
    
    my $ts = Sys::Time::Timespec->new;
    
    my $status = Sys::Time->clock_getres($clk_id, $ts);
    
    my $ret = -1.0;
    if ($status == 0) {
      $ret = $ts->tv_sec + ($ts->tv_nsec / 1_000_000_000.0);
    }
    
    return $ret;
  }
  
  private static method float_seconds_to_timespec : Sys::Time::Timespec ($double_time : double) {
    
    unless ($double_time <= Fn->INT_MAX) {
      die "\$double_time must be less than or equal to Fn->INT_MAX.";
    }
    
    my $sec = (int)$double_time;
    
    my $nsec = (int)(($double_time - $sec) * 1_000_000_000);
    
    my $ts = Sys::Time::Timespec->new;
    
    $ts->set_tv_sec($sec);
    
    $ts->set_tv_nsec($nsec);
    
    return $ts;
  }
  
  private static method timespec_to_float_seconds : double ($ts : Sys::Time::Timespec) {
    
    my $double_time = (double)$ts->tv_sec + ($ts->tv_nsec / 1_000_000_000);
    
    return $double_time;
  }
  
  static method clock_nanosleep : double ($clockid : int, $nanoseconds : double, $flags : int = 0) {
    
    my $nanoseconds_ts = &float_seconds_to_timespec($nanoseconds);
    
    my $remain_ts = Sys::Time::Timespec->new;
    
    Sys::Time->clock_nanosleep($clockid, $flags, $nanoseconds_ts, $remain_ts);
    
    my $remain_dt = &timespec_to_float_seconds($remain_ts);
    
    return $remain_dt;
  }
  
  static method clock : long () {
    my $cpu_time = Sys::Time->clock;
    
    return $cpu_time;
  }
  
  # utime LIST
  
}

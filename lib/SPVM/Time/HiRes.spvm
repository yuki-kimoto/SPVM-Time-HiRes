# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Time::HiRes {
  
  version "0.001";
  
  use Sys::Time;
  use Sys::Time::Timeval;
  use Sys::Time::Timezone;
  use Sys::Signal;
  use Sys::Process;
  use Fn;
  
  # Class Methods
  static method gettimeofday : Sys::Time::Timeval () {
  
    my $tv = Sys::Time::Timeval->new;
    
    Sys::Time->gettimeofday($tv, undef);
    
    return $tv;
  }
  
  static method usleep : int ($usec : long) {
    
    my $slept_time = Sys::Process->usleep($usec);
    
    return $slept_time;
  }
  
  static method nanosleep : int ($rqtp : Sys::Time::Timespec, $rmtp : Sys::Time::Timespec) {
    return Sys::Time->nanosleep($rqtp, $rmtp);
  }
  
  static method ualarm : int ($usecs : int, $interval : int = 0) {
    
    my $remain_time = Sys::Signal->ualarm($usecs, $interval);
    
    return $remain_time;
  }
  
  static method tv_interval : double ($a : Sys::Time::Timeval, $b : Sys::Time::Timeval = undef) {
    
    unless ($b) {
      $b = &gettimeofday;
    }
    
    my $tv_interval = ($b->tv_sec - $a->tv_sec) + ($b->tv_usec - $a->tv_usec) / 1_000_000;
    
    return $tv_interval;
  }
  
  # setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )
  # getitimer ( $which )
  
  static method clock_gettime : double ($clk_id : int) {
    
    my $ts = Sys::Time::Timespec->new;
    
    my $status = Sys::Time->clock_gettime($clk_id, $ts);
    
    my $ret = -1.0;
    if ($status == 0) {
      $ret = $ts->tv_sec + ($ts->tv_nsec / &NV_1E9);
    }
    
    return $ret;
  }

  static method clock_getres : double ($clk_id : int) {
    
    my $ts = Sys::Time::Timespec->new;
    
    my $status = Sys::Time->clock_getres($clk_id, $ts);
    
    my $ret = -1.0;
    if ($status == 0) {
      $ret = $ts->tv_sec + ($ts->tv_nsec / &NV_1E9);
    }
    
    return $ret;
  }
  
  private static method double_time_to_timespec : Sys::Time::Timespec ($double_time : double) {
    
    unless ($double_time <= Fn->INT_MAX) {
      die "\$double_time must be less than or equal to Fn->INT_MAX.";
    }
    
    my $sec = (int)$double_time;
    
    my $nsec = (int)(($double_time - $sec) * 1_000_000_000);
    
    my $ts = Sys::Time::Timespec->new;
    
    $ts->set_tv_sec($sec);
    
    $ts->set_tv_nsec($nsec);
    
    return $ts;
  }
  
  private static method timespec_to_double_time : double ($ts : Sys::Time::Timespec) {
    
    my $double_time = (double)$ts->tv_sec + ($ts->tv_nsec / 1_000_000_000);
    
    return $double_time;
  }
  
  static method clock_nanosleep : double ($clockid : int, $nanoseconds : double, $flags : int = 0) {
    
    my $nanoseconds_ts = &double_time_to_timespec($nanoseconds);
    
    my $remain_ts = Sys::Time::Timespec->new;
    
    Sys::Time->clock_nanosleep($clockid, $flags, $nanoseconds_ts, $remain_ts);
    
    my $remain_dt = &timespec_to_double_time($remain_ts);
    
    return $remain_dt;
  }
  
  static method clock : long () {
    my $cpu_time = Sys::Time->clock;
    
    return $cpu_time;
  }
  
  # utime LIST
  
  private static method IV_1E6 : long () { return 1000000L; }
  
  private static method IV_1E7 : long () { return 10000000L; }
  
  private static method IV_1E9 : long () { return 1000000000L; }
  
  private static method NV_1E6 : double () { return 1000000.0; }
  
  private static method NV_1E7 : double () { return 10000000.0; }
  
  private static method NV_1E9 : double () { return 1000000000.0; }
  
}
